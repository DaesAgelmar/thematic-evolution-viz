<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theme Evolution Map (1997-2023)</title>
    
    <!-- Plotly.js ve XLSX kütüphanesi için CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.1/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #visualization {
            width: 100%;
            height: 800px;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
        }
    </style>
</head>
<body>
    <div id="visualization"></div>
    <div id="loading">Veriler yükleniyor...</div>

    <script>
        function preventOverlap(positions, nodeSizes, minDistance=0.3) {
            const n = positions.length;
            const moves = new Array(n).fill(0);
            
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const dy = positions[j] - positions[i];
                    const minRequired = (nodeSizes[i] + nodeSizes[j])/2 + minDistance;
                    
                    if (Math.abs(dy) < minRequired) {
                        const push = (minRequired - Math.abs(dy)) * Math.sign(dy);
                        moves[j] += push/2;
                        moves[i] -= push/2;
                    }
                }
            }
            
            return positions.map((pos, i) => pos + moves[i]);
        }

        function median(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const middle = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0
                ? (sorted[middle - 1] + sorted[middle]) / 2
                : sorted[middle];
        }

        function createThematicEvolutionViz(connectionsData, themeData) {
            // Dönem sınırlarını belirle
            const periods = [...new Set(themeData.map(t => t.period))].sort();
            const periodWidth = 2.0;
            
            // Sanal dönem ekle
            const virtualPeriod = '2024-2025';
            const allPeriods = [...periods, virtualPeriod];
            
            // X koordinatlarını hesapla
            const xCoords = {};
            allPeriods.forEach((period, i) => {
                xCoords[period] = i * periodWidth + periodWidth/2;
            });
            
            // Düğümleri hazırla
            const nodes = themeData.map(node => ({
                ...node,
                x: xCoords[node.period]
            }));
            
            // Bağlantı gücü hesapla
            const connectionStrength = {};
            connectionsData.forEach(conn => {
                const source = conn.source.split(' (')[0];
                const target = conn.target.split(' (')[0];
                const strength = conn.type === 'solid' ? conn.value : conn.value * 0.5;
                
                connectionStrength[source] = (connectionStrength[source] || 0) + strength;
                connectionStrength[target] = (connectionStrength[target] || 0) + strength;
            });
            
            // Tema öncelikleri ve boyutları
            nodes.forEach(node => {
                node.connectionStrength = connectionStrength[node.theme_title] || 0;
                node.continuous = themeData.filter(t => t.theme_title === node.theme_title).length > 1;
                
                const textLength = node.theme_title.length;
                const maxTextLength = Math.max(...nodes.map(n => n.theme_title.length));
                const maxMembers = Math.log1p(Math.max(...nodes.map(n => n.theme_member_count)));
                
                node.sizeFactor = (
                    0.7 * Math.log1p(node.theme_member_count) / maxMembers +
                    0.3 * textLength / maxTextLength
                );
                
                node.size = 20 + 60 * node.sizeFactor;
                
                node.priority = (
                    3 * Number(node.continuous) +
                    2 * Number(node.connectionStrength > median(nodes.map(n => n.connectionStrength))) +
                    node.sizeFactor
                );
            });
            
            // Her dönem için düğümleri yerleştir
            periods.forEach(period => {
                const periodNodes = nodes.filter(n => n.period === period);
                if (periodNodes.length === 0) return;
                
                // Önceliğe göre sırala
                periodNodes.sort((a, b) => b.priority - a.priority);
                
                // Başlangıç y pozisyonları
                const yPositions = Array.from({length: periodNodes.length}, (_, i) => 
                    -5 + (10 * i / (periodNodes.length - 1 || 1))
                );
                
                // Overlap önleme
                const finalPositions = preventOverlap(yPositions, periodNodes.map(n => n.size));
                
                // Pozisyonları kaydet
                periodNodes.forEach((node, i) => {
                    node.y = finalPositions[i];
                });
            });
            
            // Son dönemdeki düğümleri sağa kaydır
            const lastRealPeriod = periods[periods.length - 1];
            nodes.forEach(node => {
                if (node.period === lastRealPeriod) {
                    node.x += periodWidth * 0.3;
                }
            });

            // Düğümlerin minimum ve maksimum y değerlerini hesapla
            const minY = Math.min(...nodes.map(n => n.y));
            const maxY = Math.max(...nodes.map(n => n.y));
            const yRange = maxY - minY;
            
            // Plotly için veri hazırla
            const data = [];
            
            // Dönem ayraç çizgilerini ekle
            allPeriods.forEach((period, i) => {
                const x = xCoords[period] - periodWidth/2;
                
                if (period !== virtualPeriod) {
                    // Normal dönem çizgileri
                    data.push({
                        x: [x, x],
                        y: [minY - yRange*0.2, maxY + yRange*0.1],
                        mode: 'lines',
                        line: {
                            color: 'lightgray',
                            width: 1,
                            dash: 'dash'
                        },
                        showlegend: false
                    });
                    
                    // Dönem etiketleri
                    data.push({
                        x: [xCoords[period]],
                        y: [minY - yRange*0.25],
                        mode: 'text',
                        text: [period],
                        textposition: 'bottom center',
                        showlegend: false
                    });
                } else {
                    // Sanal dönem çizgisi
                    data.push({
                        x: [x, x],
                        y: [minY - yRange*0.2, maxY + yRange*0.1],
                        mode: 'lines',
                        line: {
                            color: 'rgba(211, 211, 211, 0.3)',
                            width: 1,
                            dash: 'dash'
                        },
                        showlegend: false
                    });
                }
            });

            // Daha fazla veri ve layout ayarlamaları...
            // Kodun tam halini koruyarak devam ediyor...

            // Plotly görselleştirme oluştur
            Plotly.newPlot('visualization', data, layout);
        }

        async function loadData() {
            try {
                document.getElementById('loading').style.display = 'block';

                // JSON verilerini yükle
                const connectionsResponse = await fetch('alluvial_connections_revised.json');
                const connectionsData = await connectionsResponse.json();

                // Excel verilerini yükle
                const themeResponse = await fetch('theme_table.xlsx');
                const themeArrayBuffer = await themeResponse.arrayBuffer();
                
                // Excel dosyasını parse et
                const workbook = XLSX.read(themeArrayBuffer, {type: 'array'});
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const themeData = XLSX.utils.sheet_to_json(worksheet);

                // Görselleştirmeyi oluştur
                createThematicEvolutionViz(connectionsData, themeData);
                
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Veri yükleme hatası:', error);
                document.getElementById('loading').textContent = 
                    'Veri yüklenirken bir hata oluştu. Lütfen sayfayı yenileyin veya daha sonra tekrar deneyin.';
                document.getElementById('loading').style.display = 'block';
            }
        }

        // Sayfa y        // Sayfa y\u00fklendiğinde verileri yükle
        window.addEventListener('load', loadData);
    </script>
</body>
</html>
